<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GRIP 3D</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#06060e;font-family:'IBM Plex Mono',monospace;}
#three{position:fixed;inset:0;z-index:0;}

/* â”€â”€ HUD shell â”€â”€ */
#hud{position:fixed;inset:0;z-index:10;pointer-events:none;display:flex;flex-direction:column;}

/* â”€â”€ Header with tabs â”€â”€ */
#hdr{display:flex;align-items:center;gap:0;height:50px;
  background:linear-gradient(to bottom,rgba(6,6,14,.98) 70%,transparent);pointer-events:auto;
  border-bottom:1px solid #1a1a2e;}
#hdr h1{font-family:'Bebas Neue',sans-serif;font-size:1.75rem;letter-spacing:5px;color:#f0c040;padding:0 18px;white-space:nowrap;}
.tab{height:100%;padding:0 18px;display:flex;align-items:center;cursor:pointer;
  font-size:.65rem;letter-spacing:2px;text-transform:uppercase;color:#44446a;border-bottom:2px solid transparent;
  transition:all .15s;border-right:1px solid #1a1a2e;}
.tab:hover{color:#aaa;}
.tab.active{color:#f0c040;border-bottom-color:#f0c040;}

/* â”€â”€ Tab panels â”€â”€ */
.tabpanel{display:none;flex:1;overflow:hidden;}
.tabpanel.active{display:flex;}

/* â”€â”€ Slope tab layout â”€â”€ */
#mid{flex:1;display:flex;}
#lp{width:245px;padding:12px 14px;background:linear-gradient(to right,rgba(6,6,14,.97) 75%,transparent);
  overflow-y:auto;pointer-events:auto;scrollbar-width:thin;scrollbar-color:#1a1a2e transparent;}
#rp{width:225px;margin-left:auto;padding:12px 14px;
  background:linear-gradient(to left,rgba(6,6,14,.97) 75%,transparent);pointer-events:auto;overflow-y:auto;
  scrollbar-width:thin;scrollbar-color:#1a1a2e transparent;}

/* â”€â”€ Brake tab layout â”€â”€ */
#brake-wrap{flex:1;display:flex;align-items:stretch;}
#brake-left{width:280px;padding:16px 18px;background:linear-gradient(to right,rgba(6,6,14,.98) 75%,transparent);
  overflow-y:auto;pointer-events:auto;scrollbar-width:thin;}
#brake-right{width:320px;margin-left:auto;padding:16px 18px;
  background:linear-gradient(to left,rgba(6,6,14,.98) 75%,transparent);pointer-events:auto;overflow-y:auto;}

/* â”€â”€ Footer â”€â”€ */
#ft{height:30px;display:flex;align-items:center;justify-content:space-between;padding:0 18px;
  background:linear-gradient(to top,rgba(6,6,14,.9),transparent);font-size:.52rem;color:#33334a;letter-spacing:1px;}

/* â”€â”€ Shared panel styles â”€â”€ */
.pt{font-family:'Bebas Neue',sans-serif;font-size:.82rem;letter-spacing:3px;color:#f0c040;margin:6px 0 10px;}
.ctrl{margin-bottom:13px;}
.cl{display:block;font-size:.55rem;color:#44446a;letter-spacing:1px;text-transform:uppercase;margin-bottom:3px;}
.bv{font-family:'Bebas Neue',sans-serif;font-size:1.35rem;color:#dde0f5;line-height:1;}
.bv small{font-family:'IBM Plex Mono',monospace;font-size:.55rem;color:#44446a;}

input[type=range]{-webkit-appearance:none;width:100%;height:2px;background:#1e1e36;border-radius:2px;outline:none;margin-top:5px;}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:13px;height:13px;background:#f0c040;border-radius:50%;cursor:pointer;}
select{width:100%;background:rgba(6,6,14,.9);border:1px solid #1e1e36;color:#dde0f5;
  padding:6px 8px;font-family:'IBM Plex Mono',monospace;font-size:.66rem;border-radius:2px;outline:none;}

.g2{display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:3px;}
.g4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:3px;margin-top:3px;}
.xb{border:1px solid #1e1e36;background:rgba(6,6,14,.8);color:#44446a;padding:7px 3px;
  cursor:pointer;font-family:'IBM Plex Mono',monospace;font-size:.58rem;text-align:center;
  border-radius:2px;transition:all .12s;line-height:1.35;pointer-events:auto;}
.xb:hover{border-color:#f0c040;color:#f0c040;}
.xb.ca{background:rgba(240,192,64,.1);color:#f0c040;border-color:#f0c040;font-weight:600;}
.xb.ga{background:rgba(64,128,255,.1);color:#4080ff;border-color:#4080ff;font-weight:600;}
.nl{font-size:.52rem;color:#44446a;line-height:1.5;margin-top:4px;min-height:1.4em;}

.rbtn{width:100%;margin-top:8px;background:#f0c040;color:#000;border:none;
  font-family:'Bebas Neue',sans-serif;font-size:.95rem;letter-spacing:3px;padding:9px;
  cursor:pointer;border-radius:2px;pointer-events:auto;transition:background .12s;}
.rbtn:hover{background:#ffd060;}
.rbtn.stop{background:rgba(255,48,48,.1);color:#ff3030;border:1px solid #ff3030;}
.rstbtn{width:100%;margin-top:4px;background:transparent;color:#44446a;border:1px solid #1e1e36;
  font-family:'IBM Plex Mono',monospace;font-size:.6rem;letter-spacing:2px;padding:6px;
  cursor:pointer;border-radius:2px;pointer-events:auto;transition:all .12s;}
.rstbtn:hover{color:#dde0f5;border-color:#44446a;}

.dr{display:flex;justify-content:space-between;align-items:flex-end;padding:6px 0;border-bottom:1px solid #1a1a30;}
.dl{font-size:.55rem;color:#44446a;text-transform:uppercase;line-height:1.35;}
.dv{font-family:'Bebas Neue',sans-serif;font-size:1.05rem;line-height:1;text-align:right;color:#dde0f5;}
.dv.g{color:#30ff80;}.dv.w{color:#f0c040;}.dv.b{color:#ff3030;}

.bt{height:4px;background:#1e1e36;border-radius:3px;overflow:hidden;margin-top:3px;}
.bf{height:100%;border-radius:3px;transition:width .1s,background .25s;}

/* â”€â”€ Brake tab specific â”€â”€ */
.big-speed{font-family:'Bebas Neue',sans-serif;font-size:4.5rem;color:#f0c040;letter-spacing:4px;line-height:1;text-align:center;margin:10px 0;}
.big-speed small{font-size:1.2rem;color:#44446a;}
.brake-btn{width:100%;margin-top:14px;padding:16px;background:#ff3030;color:#fff;border:none;
  font-family:'Bebas Neue',sans-serif;font-size:1.4rem;letter-spacing:5px;
  cursor:pointer;border-radius:4px;pointer-events:auto;transition:all .15s;
  box-shadow:0 0 30px #ff303055;}
.brake-btn:hover{background:#ff5050;box-shadow:0 0 40px #ff303088;}
.brake-btn:disabled{background:#2a1010;color:#551010;box-shadow:none;cursor:default;}
.brake-btn.braking{background:#880000;animation:bpulse .4s infinite alternate;}
@keyframes bpulse{from{box-shadow:0 0 20px #ff0000}to{box-shadow:0 0 60px #ff0000,0 0 20px #ff000088}}

.rst-brake{width:100%;margin-top:6px;padding:8px;background:transparent;color:#44446a;
  border:1px solid #1e1e36;font-family:'IBM Plex Mono',monospace;font-size:.62rem;letter-spacing:2px;
  cursor:pointer;border-radius:2px;pointer-events:auto;transition:all .12s;}
.rst-brake:hover{color:#dde0f5;border-color:#44446a;}

.result-box{margin-top:14px;padding:14px;background:rgba(6,6,14,.9);border:1px solid #1e1e36;border-radius:4px;}
.result-title{font-family:'Bebas Neue',sans-serif;font-size:.75rem;letter-spacing:3px;color:#44446a;margin-bottom:8px;}
.result-big{font-family:'Bebas Neue',sans-serif;font-size:2.8rem;color:#30ff80;line-height:1;}
.result-big.warn{color:#f0c040;}
.result-big.bad{color:#ff3030;}
.result-unit{font-family:'IBM Plex Mono',monospace;font-size:.6rem;color:#44446a;}

.speedometer{position:relative;width:100%;padding-bottom:8px;}
.speed-track{height:6px;background:#1e1e36;border-radius:3px;overflow:hidden;margin-top:4px;}
.speed-fill{height:100%;border-radius:3px;background:#f0c040;transition:width .08s;}

/* â”€â”€ Overlays â”€â”€ */
#sov{position:fixed;top:42%;left:50%;transform:translate(-50%,-50%);
  font-family:'Bebas Neue',sans-serif;font-size:3.5rem;letter-spacing:8px;
  color:#ff3030;text-shadow:0 0 40px #ff303088;opacity:0;pointer-events:none;z-index:30;
  transition:opacity .15s;white-space:nowrap;}
#sov.on{opacity:1;animation:fl .3s infinite alternate;}
@keyframes fl{from{opacity:1}to{opacity:.2}}
#spd{position:fixed;bottom:40px;left:50%;transform:translateX(-50%);
  font-family:'Bebas Neue',sans-serif;font-size:2rem;color:#ff3030;letter-spacing:4px;
  text-shadow:0 0 20px #ff303066;opacity:0;z-index:30;pointer-events:none;}
#spd.on{opacity:1;}
#hint{position:fixed;bottom:36px;left:50%;transform:translateX(-50%);
  font-size:.52rem;color:#22223a;letter-spacing:2px;z-index:20;pointer-events:none;}
</style>
</head>
<body>

<div id="three"></div>
<div id="sov">âš  SLIPPING</div>
<div id="spd"></div>
<div id="hint">DRAG TO ORBIT Â· SCROLL TO ZOOM</div>

<div id="hud">
  <!-- HEADER + TABS -->
  <div id="hdr">
    <h1>GRIP</h1>
    <div class="tab active" data-tab="slope">â›° SLOPE SIM</div>
    <div class="tab" data-tab="brake">ğŸ›‘ BRAKE TEST</div>
  </div>

  <!-- â•â•â• SLOPE TAB â•â•â• -->
  <div class="tabpanel active" id="tab-slope">
    <div id="mid">
      <div id="lp">
        <div class="pt">Parameters</div>
        <div class="ctrl">
          <span class="cl">Slope Angle</span>
          <input type="range" id="sl-ang" min="0" max="80" value="15" step="0.5">
          <div class="bv" id="v-ang">15.0 <small>Â°</small></div>
        </div>
        <div class="ctrl">
          <span class="cl">Vehicle Mass</span>
          <input type="range" id="sl-mass" min="200" max="5000" value="1200" step="50">
          <div class="bv" id="v-mass">1200 <small>kg</small></div>
        </div>
        <div class="ctrl">
          <span class="cl">Surface</span>
          <select id="sel-surf">
            <option value="1.0|dry">Dry Asphalt</option>
            <option value="0.60|wet">Wet Asphalt</option>
            <option value="0.28|snow">Packed Snow</option>
            <option value="0.10|ice">Black Ice</option>
            <option value="0.46|dry">Dry Gravel</option>
            <option value="0.48|wet">Wet Gravel</option>
            <option value="0.52|wet">Wet Grass</option>
          </select>
        </div>
        <div class="ctrl">
          <span class="cl">Tyre Compound</span>
          <div class="g2">
            <button class="xb" data-c="HARD">HARD<br>RUBBER</button>
            <button class="xb ca" data-c="SOFT">SOFT<br>RUBBER</button>
            <button class="xb" data-c="SAND">SAND-<br>PAPER</button>
            <button class="xb" data-c="PTFE">TEFLON<br><span style="font-size:.44rem;color:#33334a">slippery</span></button>
          </div>
          <div class="nl" id="cnote">Soft rubber deforms to maximise contact patch.</div>
        </div>
        <div class="ctrl">
          <span class="cl">Groove Depth</span>
          <div class="g4">
            <button class="xb" data-g="0">SLICK</button>
            <button class="xb" data-g="1">SHAL</button>
            <button class="xb ga" data-g="2">MED</button>
            <button class="xb" data-g="3">DEEP</button>
          </div>
          <div class="nl" id="gnote"></div>
        </div>
        <button class="rbtn" id="btn-run">â–¶ RUN</button>
        <button class="rstbtn" id="btn-rst">â†º RESET</button>
      </div>

      <div id="rp">
        <div class="pt">Live Data</div>
        <div class="dr"><div class="dl">Angle</div><div class="dv" id="d-ang">â€”</div></div>
        <div class="dr"><div class="dl">Speed</div><div class="dv" id="d-vel">â€”</div></div>
        <div class="dr"><div class="dl">Sliding Distance</div><div class="dv" id="d-dst">â€”</div></div>
        <div class="dr"><div class="dl">Status</div><div class="dv" id="d-st">â€”</div></div>
        <div style="margin-top:8px;"><span class="cl">How Close to Slipping</span>
          <div class="bt"><div class="bf" id="grip-bar" style="width:100%;background:#30ff80"></div></div>
        </div>
        <div style="margin-top:10px;padding:8px;background:rgba(6,6,14,.8);border:1px solid #1a1a30;border-radius:2px;font-size:.55rem;color:#44446a;line-height:2;">
          <div style="color:#f0c040;letter-spacing:2px;margin-bottom:4px;">HOW IT WORKS</div>
          The steeper the hill, the more the car<br>
          wants to slide. Friction holds it in place.<br>
          When gravity wins â†’ the car slides.<br>
          Once sliding, it's hard to stop.<br>
          <span style="color:#f0c040">On ice: smooth tyres grip best â€”<br>grooves have nothing to dig into.</span>
        </div>
      </div>
    </div>
  </div>

  <!-- â•â•â• BRAKE TAB â•â•â• -->
  <div class="tabpanel" id="tab-brake">
    <div id="brake-wrap">
      <div id="brake-left">
        <div class="pt">Brake Test Setup</div>

        <div class="ctrl">
          <span class="cl">Initial Speed</span>
          <input type="range" id="b-speed" min="5" max="200" value="60" step="1">
          <div class="big-speed" id="bv-speed">60 <small>km/h</small></div>
        </div>

        <div class="ctrl">
          <span class="cl">Vehicle Mass</span>
          <input type="range" id="b-mass" min="500" max="5000" value="1500" step="50">
          <div class="bv" id="bv-mass">1500 <small>kg</small></div>
        </div>

        <div class="ctrl">
          <span class="cl">Surface</span>
          <select id="b-surf">
            <option value="1.0|dry">Dry Asphalt</option>
            <option value="0.60|wet">Wet Asphalt</option>
            <option value="0.28|snow">Packed Snow</option>
            <option value="0.10|ice">Black Ice</option>
            <option value="0.46|dry">Dry Gravel</option>
            <option value="0.48|wet">Wet Gravel</option>
          </select>
        </div>

        <div class="ctrl">
          <span class="cl">Tyre Compound</span>
          <div class="g2">
            <button class="xb" data-bc="HARD">HARD<br>RUBBER</button>
            <button class="xb ca" data-bc="SOFT">SOFT<br>RUBBER</button>
            <button class="xb" data-bc="SAND">SAND-<br>PAPER</button>
            <button class="xb" data-bc="PTFE">TEFLON</button>
          </div>
          <div class="nl" id="b-cnote">Soft rubber â€” max contact patch.</div>
        </div>

        <div class="ctrl">
          <span class="cl">Groove Depth</span>
          <div class="g4">
            <button class="xb" data-bg="0">SLICK</button>
            <button class="xb" data-bg="1">SHAL</button>
            <button class="xb ga" data-bg="2">MED</button>
            <button class="xb" data-bg="3">DEEP</button>
          </div>
          <div class="nl" id="b-gnote"></div>
        </div>

        <button class="brake-btn" id="btn-brake">ğŸ›‘ BRAKE</button>
        <button class="rst-brake" id="btn-brake-rst">â†º RESET</button>
      </div>

      <div id="brake-right">
        <div class="pt">Braking Data</div>

        <div class="speedometer ctrl">
          <span class="cl">Current Speed</span>
          <div class="bv" id="b-cur-spd" style="font-size:2rem;">â€” <small>km/h</small></div>
          <div class="speed-track"><div class="speed-fill" id="b-spd-bar" style="width:0%"></div></div>
        </div>

        <div class="dr"><div class="dl">Slowing Down At</div><div class="dv" id="b-decel">â€”</div></div>
        <div class="dr"><div class="dl">Distance Travelled</div><div class="dv" id="b-dst">â€”</div></div>

        <div class="result-box" id="b-result-box" style="display:none;">
          <div class="result-title">STOPPED â€” TOTAL STOPPING DISTANCE</div>
          <div class="result-big" id="b-result-dist">â€”</div>
          <div class="result-unit">metres</div>
          <div style="margin-top:8px;font-size:.56rem;color:#44446a;line-height:1.9;" id="b-result-detail"></div>
        </div>

        <div style="margin-top:12px;padding:10px;background:rgba(6,6,14,.85);border:1px solid #1a1a30;border-radius:2px;font-size:.55rem;color:#44446a;line-height:2;">
          <div style="color:#f0c040;letter-spacing:2px;margin-bottom:4px;">HOW IT WORKS</div>
          The faster you go, the longer it takes<br>
          to stop. Better grip = shorter stop.<br>
          Heavier car = harder to slow down.<br>
          <span style="color:#f0c040">On ice: slick tyres stop shorter â€”<br>grooves can't grip solid ice.</span>
        </div>
      </div>
    </div>
  </div>

  <div id="ft">
    <span>More grip = shorter stopping distance Â· On ice, smooth tyres work best</span>
    <span>grip 3d âˆ</span>
  </div>
</div>

<script>
(function(){
const s=document.createElement('script');
s.src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
s.onload=boot;
s.onerror=()=>{document.getElementById('three').innerHTML='<div style="color:#ff3030;padding:40px;font-size:1.2rem;">Failed to load Three.js</div>';};
document.head.appendChild(s);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHYSICS DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CDATA={
  HARD:{mus:.80,muk:.58,hexCol:0xbbbbbb,note:'Stiff. Less deformation = less contact area.'},
  SOFT:{mus:1.20,muk:.92,hexCol:0xff4444,note:'Best dry grip. Deforms to maximise contact patch.'},
  SAND:{mus:.70,muk:.50,hexCol:0xcc9944,note:'Rigid & abrasive. Poor surface conformity = low grip.'},
  PTFE:{mus:.12,muk:.06,hexCol:0x88ddff,note:'Near-zero friction. Slippery control compound.'},
};

// Groove effects per surface type
// KEY CHANGE: On ice, grooves HURT â€” slick is best. Ice is already near-zero friction;
// grooves reduce contact area without being able to channel water (it's solid).
// On wet/snow: grooves help by channelling water/slush away.
const GDATA={
  //       dry    wet   snow   ice
  0:{dry:1.00,wet:0.40,snow:0.30,ice:1.00,note:'Slick: max dry + max ice grip. Zero wet channel.'},
  1:{dry:0.93,wet:0.75,snow:0.65,ice:0.90,note:'Shallow: mild wet help, small dry/ice penalty.'},
  2:{dry:0.85,wet:1.00,snow:0.85,ice:0.80,note:'Medium: balanced for wet roads. Hurts on ice.'},
  3:{dry:0.75,wet:1.10,snow:1.10,ice:0.65,note:'Deep: best for wet/snow. Big penalty on ice.'},
};

const G=9.81;

function grooveMult(grooveLevel,surfType){
  const g=GDATA[grooveLevel];
  return g[surfType] ?? g.dry;
}

// â”€â”€ Slope sim state â”€â”€
const ST={angle:15,mass:1200,surfMu:1.0,surfType:'dry',compound:'SOFT',groove:2};
const SIM={running:false,slipping:false,vel:0,dist:0,wheelAng:0,lastT:null};

function calcPhysics(){
  const th=ST.angle*Math.PI/180;
  const c=CDATA[ST.compound];
  const gm=grooveMult(ST.groove,ST.surfType);
  const mus=c.mus*ST.surfMu*gm;
  const muk=c.muk*ST.surfMu*gm;
  const fN=ST.mass*G*Math.cos(th);
  const fD=ST.mass*G*Math.sin(th);
  const fS=mus*fN, fK=muk*fN;
  const acc=SIM.slipping?(fD-fK)/ST.mass:0;
  const thr=Math.atan(mus)*180/Math.PI;
  const grip=Math.min(1,fS/Math.max(fD,.001));
  return{fD,fN,fS,fK,acc,thr,grip,gm};
}

// â”€â”€ Brake test state â”€â”€
const BST={speedKph:60,mass:1500,surfMu:1.0,surfType:'dry',compound:'SOFT',groove:2};
const BSIM={braking:false,vel:0,dist:0,lastT:null,done:false};

function calcBrakePhysics(){
  const c=CDATA[BST.compound];
  const gm=grooveMult(BST.groove,BST.surfType);
  const muEff=c.muk*BST.surfMu*gm;
  const fN=BST.mass*G;
  const fBrake=muEff*fN;
  const decel=fBrake/BST.mass;
  return{muEff,fBrake,decel,gm};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function boot(){
// â”€â”€ RENDERER â”€â”€
const W=()=>window.innerWidth,H=()=>window.innerHeight;
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(W(),H());
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=.88;
document.getElementById('three').appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x070c18);
scene.fog=new THREE.FogExp2(0x070c18,.023);

const camera=new THREE.PerspectiveCamera(55,W()/H(),.1,300);
window.addEventListener('resize',()=>{renderer.setSize(W(),H());camera.aspect=W()/H();camera.updateProjectionMatrix();});

// â”€â”€ LIGHTS â”€â”€
scene.add(new THREE.AmbientLight(0x202040,1.5));
const sun=new THREE.DirectionalLight(0xfff0dd,3.0);
sun.position.set(8,16,6);sun.castShadow=true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left=-25;sun.shadow.camera.right=25;
sun.shadow.camera.top=25;sun.shadow.camera.bottom=-25;sun.shadow.camera.far=60;
scene.add(sun);
const fill=new THREE.DirectionalLight(0x3060ff,.6);
fill.position.set(-8,5,-10);scene.add(fill);
const carFill=new THREE.PointLight(0xffeedd,2,14);
carFill.position.set(0,6,0);scene.add(carFill);

// â”€â”€ SLOPE GROUP â”€â”€
const slopeGroup=new THREE.Group();
scene.add(slopeGroup);

// Road tiles
const TILE_L=18,TILE_W=5.5,TILE_N=7;
const roadMat=new THREE.MeshStandardMaterial({color:0x1a1a22,roughness:.92,metalness:.04});
const curbWMat=new THREE.MeshStandardMaterial({color:0xeeeeee,roughness:.7});
const curbRMat=new THREE.MeshStandardMaterial({color:0xdd2222,roughness:.7});
const dashMat=new THREE.MeshStandardMaterial({color:0x404055,roughness:1});
const edgeMat=new THREE.MeshStandardMaterial({color:0xcccccc,roughness:.8});

function makeTile(zStart){
  const g=new THREE.Group();
  const road=new THREE.Mesh(new THREE.BoxGeometry(TILE_W,.2,TILE_L),roadMat);
  road.position.y=-.1;road.receiveShadow=true;g.add(road);
  const KSEG=5;
  for(let i=0;i<KSEG;i++){
    const mat=i%2===0?curbWMat:curbRMat;
    const kl=TILE_L/KSEG-.06;
    const kz=-TILE_L/2+i*(TILE_L/KSEG)+kl/2+.03;
    [-TILE_W/2+.18,TILE_W/2-.18].forEach(kx=>{
      const k=new THREE.Mesh(new THREE.BoxGeometry(.35,.3,kl),mat);
      k.position.set(kx,.05,kz);k.castShadow=true;g.add(k);
    });
  }
  [-TILE_W/2+.45,TILE_W/2-.45].forEach(ex=>{
    const e=new THREE.Mesh(new THREE.BoxGeometry(.1,.005,TILE_L),edgeMat);
    e.position.set(ex,.003,0);g.add(e);
  });
  for(let d=0;d<7;d++){
    const dz=-TILE_L/2+d*(TILE_L/7)+(TILE_L/7)*.4;
    const dash=new THREE.Mesh(new THREE.BoxGeometry(.08,.005,TILE_L/7*.55),dashMat);
    dash.position.set(0,.003,dz);g.add(dash);
  }
  g.position.z=zStart;slopeGroup.add(g);return g;
}
const tiles=[];for(let i=0;i<TILE_N;i++)tiles.push(makeTile(-i*TILE_L));

const bankMat=new THREE.MeshStandardMaterial({color:0x0d180d,roughness:1});
const bankTiles=[];
function makeBank(zStart){
  const g=new THREE.Group();
  [-TILE_W/2-2,TILE_W/2+2].forEach(bx=>{
    const b=new THREE.Mesh(new THREE.BoxGeometry(4,.15,TILE_L),bankMat);
    b.position.set(bx,-.04,0);b.receiveShadow=true;g.add(b);
  });
  g.position.z=zStart;slopeGroup.add(g);return g;
}
for(let i=0;i<TILE_N;i++)bankTiles.push(makeBank(-i*TILE_L));

// Trees
const treeMeshes=[];
const TREE_COUNT=70;
function randX(){const s=Math.random()<.5?-1:1;return s*(TILE_W/2+1.2+Math.random()*5.5);}
function makeTree(x,z){
  const g=new THREE.Group();
  const h=2+Math.random()*2.5;
  const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.08,.14,h*.4,6),
    new THREE.MeshStandardMaterial({color:0x3a1e08,roughness:1}));
  trunk.position.y=h*.2;trunk.castShadow=true;g.add(trunk);
  const gCol=new THREE.Color(0x0d3d10).lerp(new THREE.Color(0x1a6620),Math.random());
  const tMat=new THREE.MeshStandardMaterial({color:gCol,roughness:.9});
  for(let l=0;l<3;l++){
    const r=(.6-l*.12)*(.85+Math.random()*.3);
    const lh=.85+Math.random()*.35;
    const cone=new THREE.Mesh(new THREE.ConeGeometry(r,lh,7),tMat);
    cone.position.y=h*.38+l*(lh*.5)+lh*.5;cone.castShadow=true;g.add(cone);
  }
  g.position.set(x,0,z);g.rotation.y=Math.random()*Math.PI*2;
  g.scale.setScalar(.85+Math.random()*.35);
  slopeGroup.add(g);return g;
}
for(let i=0;i<TREE_COUNT;i++)treeMeshes.push(makeTree(randX(),-Math.random()*TILE_L*TILE_N));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAR
// Tyre geometry: TorusGeometry(0.3, 0.118) â†’ outer radius = 0.3+0.118 = 0.418
// Road surface y=0. Car group y must = 0.418 so tyre bottom sits exactly on road.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const WHEEL_R = 0.418; // tyre outer radius (0.3 tube centre + 0.118 tube radius)
const car=new THREE.Group();
car.position.set(0, WHEEL_R, -6);
slopeGroup.add(car);

const bodyMat=new THREE.MeshStandardMaterial({color:0x1e2060,roughness:.3,metalness:.75});
const body=new THREE.Mesh(new THREE.BoxGeometry(1.6,.52,2.9),bodyMat);
// Body bottom at y=0 (wheel axle height), body centre at y=0.26
body.position.y=0.26;body.castShadow=true;car.add(body);

// Cabin sits on top of body (body top = 0.26+0.26=0.52)
const cabin=new THREE.Mesh(new THREE.BoxGeometry(1.28,.4,1.5),
  new THREE.MeshStandardMaterial({color:0x252870,roughness:.25,metalness:.6}));
cabin.position.set(0,.72+.2,-.1);cabin.castShadow=true;car.add(cabin);

// Glass
const glassMat=new THREE.MeshStandardMaterial({color:0xaaccff,roughness:0,metalness:.05,transparent:true,opacity:.38});
const wind=new THREE.Mesh(new THREE.BoxGeometry(1.26,.38,.05),glassMat);
wind.position.set(0,.72+.19,.62);car.add(wind);
const rwind=new THREE.Mesh(new THREE.BoxGeometry(1.26,.38,.05),glassMat);
rwind.position.set(0,.72+.19,-.82);car.add(rwind);

// Lights
const hlGeo=new THREE.BoxGeometry(.3,.13,.07);
const hlMat=new THREE.MeshStandardMaterial({color:0xffffcc,emissive:0xffffaa,emissiveIntensity:2.5});
const tlMat=new THREE.MeshStandardMaterial({color:0xff1100,emissive:0xff1100,emissiveIntensity:2});
[-0.5,0.5].forEach(x=>{
  const hl=new THREE.Mesh(hlGeo,hlMat);hl.position.set(x,.26,1.46);car.add(hl);
  const tl=new THREE.Mesh(hlGeo,tlMat);tl.position.set(x,.26,-1.46);car.add(tl);
});

// Grille
const grille=new THREE.Mesh(new THREE.BoxGeometry(1,.22,.06),
  new THREE.MeshStandardMaterial({color:0x111122,roughness:.5,metalness:.9}));
grille.position.set(0,.26,1.47);car.add(grille);

// Undercarriage
const skirt=new THREE.Mesh(new THREE.BoxGeometry(1.65,.1,2.95),
  new THREE.MeshStandardMaterial({color:0x0d0d1a,roughness:.6,metalness:.5}));
skirt.position.y=.05;car.add(skirt);

// Beacon
const beaconMat=new THREE.MeshStandardMaterial({color:0x30ff80,emissive:0x30ff80,emissiveIntensity:4});
const beacon=new THREE.Mesh(new THREE.SphereGeometry(.075,10,10),beaconMat);
beacon.position.set(0,1.14,0);car.add(beacon);
const beaconPt=new THREE.PointLight(0x30ff80,2.5,5);
beaconPt.position.set(0,1.25,0);car.add(beaconPt);

// â”€â”€ WHEELS â”€â”€
// Wheel axle is at y=0 in car local space (car.position.y = WHEEL_R puts axle at WHEEL_R above road)
// Tyre torus sits centred at y=0, outer edge at y=Â±0.418
const wheels=[];

function buildGrooveRings(wg,n){
  wg.children.filter(c=>c.userData.isGroove).forEach(c=>wg.remove(c));
  if(n===0)return;
  const gMat=new THREE.MeshStandardMaterial({color:0x020202,roughness:1});
  const offsets=[[],[0],[-0.072,.072],[-0.115,0,.115]][n]||[];
  offsets.forEach(ox=>{
    const ring=new THREE.Mesh(new THREE.TorusGeometry(.3,.011,8,40),gMat);
    ring.rotation.y=Math.PI/2;ring.position.x=ox;ring.userData.isGroove=true;wg.add(ring);
    for(let s=0;s<24;s++){
      const ang=(s/24)*Math.PI*2;
      const py=Math.sin(ang)*.302,pz=Math.cos(ang)*.302;
      const slot=new THREE.Mesh(new THREE.BoxGeometry(.022,.028,.026),gMat);
      slot.position.set(ox,py,pz);
      slot.lookAt(new THREE.Vector3(ox,py*2,pz*2));
      slot.userData.isGroove=true;wg.add(slot);
    }
  });
}

function makeWheel(){
  const wg=new THREE.Group();
  const c=CDATA[ST.compound];
  const tyreMat=new THREE.MeshStandardMaterial({color:c.hexCol,roughness:.86,metalness:.04});
  const tyre=new THREE.Mesh(new THREE.TorusGeometry(.3,.118,20,40),tyreMat);
  tyre.rotation.y=Math.PI/2;tyre.castShadow=true;wg.add(tyre);
  wg.userData.tyreMat=tyreMat;
  buildGrooveRings(wg,ST.groove);
  const rim=new THREE.Mesh(new THREE.CylinderGeometry(.23,.23,.1,24),
    new THREE.MeshStandardMaterial({color:0x667788,roughness:.2,metalness:.9}));
  rim.rotation.z=Math.PI/2;rim.castShadow=true;wg.add(rim);
  for(let i=0;i<5;i++){
    const sg=new THREE.Group();
    const spoke=new THREE.Mesh(new THREE.BoxGeometry(.036,.2,.04),
      new THREE.MeshStandardMaterial({color:0x778899,metalness:.9,roughness:.2}));
    spoke.rotation.x=(i/5)*Math.PI*2;sg.add(spoke);sg.rotation.z=Math.PI/2;wg.add(sg);
  }
  const hub=new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,.12,12),
    new THREE.MeshStandardMaterial({color:0x99aabb,metalness:1,roughness:.08}));
  hub.rotation.z=Math.PI/2;wg.add(hub);
  wg.userData.rebuild=()=>buildGrooveRings(wg,ST.groove);
  return wg;
}

// Wheel axle height = 0 in car local space
// (car group already lifted by WHEEL_R, so axle is at WHEEL_R world height = correct)
const WPOS=[{x:-.86,z:1.0},{x:.86,z:1.0},{x:-.86,z:-1.0},{x:.86,z:-1.0}];
WPOS.forEach(p=>{
  const w=makeWheel();
  w.position.set(p.x,0,p.z); // y=0 â†’ axle at wheel-radius height above road
  car.add(w);wheels.push(w);
});

// â”€â”€ TILT â”€â”€
function applyTilt(){
  const rad=ST.angle*Math.PI/180;
  slopeGroup.rotation.x=rad;
  slopeGroup.position.y=-1.5-Math.sin(rad)*4;
  slopeGroup.position.z=2+Math.cos(rad)*1;
}
applyTilt();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAT ROAD FOR BRAKE TAB
// Separate group, always rotation.x = 0 (flat)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const brakeGroup = new THREE.Group();
brakeGroup.visible = false;
scene.add(brakeGroup);

// Flat road tiles
const bRoadMat = new THREE.MeshStandardMaterial({color:0x1a1a22,roughness:.92,metalness:.04});
const bTiles = [];
function makeBrakeTile(zStart){
  const g=new THREE.Group();
  const road=new THREE.Mesh(new THREE.BoxGeometry(5.5,.2,TILE_L),bRoadMat);
  road.position.y=-.1;road.receiveShadow=true;g.add(road);
  // Kerbs
  const KSEG=5;
  for(let i=0;i<KSEG;i++){
    const mat=i%2===0?curbWMat:curbRMat;
    const kl=TILE_L/KSEG-.06;
    const kz=-TILE_L/2+i*(TILE_L/KSEG)+kl/2+.03;
    [-5.5/2+.18,5.5/2-.18].forEach(kx=>{
      const k=new THREE.Mesh(new THREE.BoxGeometry(.35,.3,kl),mat);
      k.position.set(kx,.05,kz);g.add(k);
    });
  }
  // Centre dashes
  for(let d=0;d<7;d++){
    const dz=-TILE_L/2+d*(TILE_L/7)+(TILE_L/7)*.4;
    const dash=new THREE.Mesh(new THREE.BoxGeometry(.08,.005,TILE_L/7*.55),dashMat);
    dash.position.set(0,.003,dz);g.add(dash);
  }
  g.position.z=zStart;brakeGroup.add(g);return g;
}
for(let i=0;i<TILE_N;i++) bTiles.push(makeBrakeTile(-i*TILE_L));

// Flat bank
const bBankTiles=[];
function makeBrakeBank(zStart){
  const g=new THREE.Group();
  [-5.5/2-2,5.5/2+2].forEach(bx=>{
    const b=new THREE.Mesh(new THREE.BoxGeometry(4,.15,TILE_L),bankMat);
    b.position.set(bx,-.04,0);b.receiveShadow=true;g.add(b);
  });
  g.position.z=zStart;brakeGroup.add(g);return g;
}
for(let i=0;i<TILE_N;i++) bBankTiles.push(makeBrakeBank(-i*TILE_L));

// Flat trees
const bTrees=[];
function randBX(){const s=Math.random()<.5?-1:1;return s*(5.5/2+1.2+Math.random()*5.5);}
for(let i=0;i<40;i++){
  const g=new THREE.Group();
  const h=2+Math.random()*2.5;
  const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.08,.14,h*.4,6),
    new THREE.MeshStandardMaterial({color:0x3a1e08,roughness:1}));
  trunk.position.y=h*.2;g.add(trunk);
  const gCol=new THREE.Color(0x0d3d10).lerp(new THREE.Color(0x1a6620),Math.random());
  const tMat2=new THREE.MeshStandardMaterial({color:gCol,roughness:.9});
  for(let l=0;l<3;l++){
    const r=(.6-l*.12)*(.85+Math.random()*.3);
    const lh=.85+Math.random()*.35;
    const cone=new THREE.Mesh(new THREE.ConeGeometry(r,lh,7),tMat2);
    cone.position.y=h*.38+l*(lh*.5)+lh*.5;g.add(cone);
  }
  g.position.set(randBX(),0,-Math.random()*TILE_L*TILE_N);
  g.rotation.y=Math.random()*Math.PI*2;g.scale.setScalar(.85+Math.random()*.35);
  brakeGroup.add(g);bTrees.push(g);
}

// Brake car (separate from slope car)
const BCAR = new THREE.Group();
BCAR.position.set(0, WHEEL_R, -6);
brakeGroup.add(BCAR);

const bBodyMat=new THREE.MeshStandardMaterial({color:0x203060,roughness:.3,metalness:.75});
const bBody=new THREE.Mesh(new THREE.BoxGeometry(1.6,.52,2.9),bBodyMat);
bBody.position.y=.26;bBody.castShadow=true;BCAR.add(bBody);
const bCabin=new THREE.Mesh(new THREE.BoxGeometry(1.28,.4,1.5),
  new THREE.MeshStandardMaterial({color:0x283278,roughness:.25,metalness:.6}));
bCabin.position.set(0,.72+.2,-.1);bCabin.castShadow=true;BCAR.add(bCabin);
const bGlassMat=new THREE.MeshStandardMaterial({color:0xaaccff,roughness:0,transparent:true,opacity:.38});
const bWind=new THREE.Mesh(new THREE.BoxGeometry(1.26,.38,.05),bGlassMat);
bWind.position.set(0,.72+.19,.62);BCAR.add(bWind);
// Headlights & taillights
[-0.5,0.5].forEach(x=>{
  const hl=new THREE.Mesh(new THREE.BoxGeometry(.3,.13,.07),
    new THREE.MeshStandardMaterial({color:0xffffcc,emissive:0xffffaa,emissiveIntensity:2.5}));
  hl.position.set(x,.26,1.46);BCAR.add(hl);
  const tl=new THREE.Mesh(new THREE.BoxGeometry(.3,.13,.07),
    new THREE.MeshStandardMaterial({color:0xff1100,emissive:0xff1100,emissiveIntensity:2}));
  tl.position.set(x,.26,-1.46);BCAR.add(tl);
});
// Grille
const bGrille=new THREE.Mesh(new THREE.BoxGeometry(1,.22,.06),
  new THREE.MeshStandardMaterial({color:0x111122,roughness:.5,metalness:.9}));
bGrille.position.set(0,.26,1.47);BCAR.add(bGrille);
// Skirt
const bSkirt=new THREE.Mesh(new THREE.BoxGeometry(1.65,.1,2.95),
  new THREE.MeshStandardMaterial({color:0x0d0d1a,roughness:.6,metalness:.5}));
bSkirt.position.y=.05;BCAR.add(bSkirt);

// Brake lights (red when braking)
const brakeLightMat = new THREE.MeshStandardMaterial({color:0xff0000,emissive:0xff0000,emissiveIntensity:0});
[-0.5,0.5].forEach(x=>{
  const bl=new THREE.Mesh(new THREE.BoxGeometry(.28,.12,.04),brakeLightMat);
  bl.position.set(x,.26,-1.48);BCAR.add(bl);
});

// Brake wheels
const bWheels=[];
WPOS.forEach(p=>{
  const wg=new THREE.Group();
  const tyreMat2=new THREE.MeshStandardMaterial({color:CDATA[BST.compound].hexCol,roughness:.86,metalness:.04});
  const tyre2=new THREE.Mesh(new THREE.TorusGeometry(.3,.118,20,40),tyreMat2);
  tyre2.rotation.y=Math.PI/2;tyre2.castShadow=true;wg.add(tyre2);
  wg.userData.tyreMat=tyreMat2;
  buildGrooveRings(wg,BST.groove);
  const rim2=new THREE.Mesh(new THREE.CylinderGeometry(.23,.23,.1,24),
    new THREE.MeshStandardMaterial({color:0x667788,roughness:.2,metalness:.9}));
  rim2.rotation.z=Math.PI/2;wg.add(rim2);
  for(let i=0;i<5;i++){
    const sg=new THREE.Group();
    const spk=new THREE.Mesh(new THREE.BoxGeometry(.036,.2,.04),
      new THREE.MeshStandardMaterial({color:0x778899,metalness:.9,roughness:.2}));
    spk.rotation.x=(i/5)*Math.PI*2;sg.add(spk);sg.rotation.z=Math.PI/2;wg.add(sg);
  }
  const hub2=new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,.12,12),
    new THREE.MeshStandardMaterial({color:0x99aabb,metalness:1,roughness:.08}));
  hub2.rotation.z=Math.PI/2;wg.add(hub2);
  wg.userData.rebuild=()=>buildGrooveRings(wg,BST.groove);
  wg.position.set(p.x,0,p.z);
  BCAR.add(wg);bWheels.push(wg);
});

let bWheelAng=0;

// Tab visibility toggle
let activeTab='slope';
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click',function(){
    activeTab=this.dataset.tab;
    slopeGroup.visible=(activeTab==='slope');
    brakeGroup.visible=(activeTab==='brake');
  });
});
// init
slopeGroup.visible=true;
brakeGroup.visible=false;

// â”€â”€ CAMERA ORBIT â”€â”€
let oTheta=.15,oPhi=.44,oR=10;
const camTarget=new THREE.Vector3();
let drag=false,lastMX=0,lastMY=0;
const domEl=renderer.domElement;
domEl.addEventListener('mousedown',e=>{drag=true;lastMX=e.clientX;lastMY=e.clientY;});
window.addEventListener('mouseup',()=>drag=false);
window.addEventListener('mousemove',e=>{
  if(!drag)return;
  oTheta-=(e.clientX-lastMX)*.007;
  oPhi=Math.max(.05,Math.min(1.5,oPhi-(e.clientY-lastMY)*.007));
  lastMX=e.clientX;lastMY=e.clientY;
});
domEl.addEventListener('wheel',e=>{oR=Math.max(3,Math.min(40,oR+e.deltaY*.018));},{passive:true});
let lt=null;
domEl.addEventListener('touchstart',e=>{if(e.touches.length===1){drag=true;lt={x:e.touches[0].clientX,y:e.touches[0].clientY};}});
window.addEventListener('touchend',()=>{drag=false;lt=null;});
window.addEventListener('touchmove',e=>{
  if(!drag||!lt||e.touches.length!==1)return;
  oTheta-=(e.touches[0].clientX-lt.x)*.007;
  oPhi=Math.max(.05,Math.min(1.5,oPhi-(e.touches[0].clientY-lt.y)*.007));
  lt={x:e.touches[0].clientX,y:e.touches[0].clientY};
});
function updateCamera(){
  camera.position.set(
    camTarget.x+oR*Math.sin(oPhi)*Math.sin(oTheta),
    camTarget.y+oR*Math.cos(oPhi),
    camTarget.z+oR*Math.sin(oPhi)*Math.cos(oTheta));
  camera.lookAt(camTarget);
}

// â”€â”€ SKID MARKS â”€â”€
const skidMeshes=[];const MAX_SKID=100;let skidT=0;
const skidMatBase=new THREE.MeshStandardMaterial({color:0x060000,roughness:1,transparent:true,opacity:.7});
function addSkid(){
  if(!SIM.slipping||SIM.vel<.3)return;
  [-0.6,.6].forEach(xOff=>{
    const m=new THREE.Mesh(new THREE.BoxGeometry(.1,.003,.2),skidMatBase.clone());
    m.position.set(car.position.x+xOff,.004,car.position.z);
    m.material.opacity=Math.min(.75,SIM.vel*.1);
    slopeGroup.add(m);skidMeshes.push(m);
    if(skidMeshes.length>MAX_SKID){const o=skidMeshes.shift();slopeGroup.remove(o);}
  });
}

// â”€â”€ SMOKE â”€â”€
const smokeArr=[];
function spawnSmoke(){
  if(!SIM.slipping||SIM.vel<1)return;
  WPOS.forEach(wp=>{
    if(Math.random()>.55)return;
    const m=new THREE.Mesh(new THREE.SphereGeometry(.06+Math.random()*.09,5,5),
      new THREE.MeshStandardMaterial({color:0x221100,transparent:true,opacity:.3}));
    const wp3=new THREE.Vector3(car.position.x+wp.x,car.position.y+.15,car.position.z+wp.z);
    slopeGroup.localToWorld(wp3);m.position.copy(wp3);
    m.userData.v=new THREE.Vector3((Math.random()-.5)*.05,.04+Math.random()*.05,(Math.random()-.5)*.05);
    m.userData.life=1;scene.add(m);smokeArr.push(m);
  });
}
function tickSmoke(dt){
  for(let i=smokeArr.length-1;i>=0;i--){
    const p=smokeArr[i];p.userData.life-=dt*1.5;
    p.material.opacity=p.userData.life*.28;p.scale.setScalar(1+(1-p.userData.life)*2.5);
    p.position.addScaledVector(p.userData.v,dt*60);
    if(p.userData.life<=0){scene.remove(p);smokeArr.splice(i,1);}
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SCROLL=2.2;

function animate(ts){
  requestAnimationFrame(animate);
  const dt=Math.min((ts-(SIM.lastT||ts))/1000,.05);
  SIM.lastT=ts;

  const p=calcPhysics();

  if(SIM.running){
    if(!SIM.slipping&&p.fD>p.fS){SIM.slipping=true;SIM.vel=.008;}
    if(SIM.slipping){
      SIM.vel+=p.acc*dt;
      if(SIM.vel<=0){SIM.vel=0;SIM.slipping=false;}
      SIM.dist+=SIM.vel*dt;
      skidT-=dt;if(skidT<0){addSkid();skidT=.05;}
      if(Math.random()<SIM.vel*.3*dt*60)spawnSmoke();
    }
  }

  const scrollSpeed=SIM.running
    ?(SIM.slipping?SIM.vel:Math.min(.4,(p.fD/Math.max(p.fS,.01))*.35))
    :0;
  const dz=scrollSpeed*SCROLL*dt;

  tiles.forEach(t=>{
    t.position.z-=dz;
    if(t.position.z<car.position.z-TILE_L*(TILE_N-.5))t.position.z+=TILE_N*TILE_L;
  });
  bankTiles.forEach(t=>{
    t.position.z-=dz;
    if(t.position.z<car.position.z-TILE_L*(TILE_N-.5))t.position.z+=TILE_N*TILE_L;
  });
  treeMeshes.forEach(t=>{
    t.position.z-=dz;
    if(t.position.z<car.position.z-TILE_L*(TILE_N-1)){
      t.position.z+=TILE_N*TILE_L+Math.random()*TILE_L;
      t.position.x=randX();t.rotation.y=Math.random()*Math.PI*2;
    }
  });

  const stretch=1+Math.min(SIM.vel*.018,.18);
  treeMeshes.forEach(t=>{t.scale.z=stretch;});

  SIM.wheelAng+=(SIM.vel*2.8+(SIM.slipping?5:0))*dt;
  wheels.forEach(w=>{w.rotation.x=SIM.wheelAng;});

  const slp=SIM.slipping;
  beaconMat.color.setHex(slp?0xff3030:0x30ff80);
  beaconMat.emissive.setHex(slp?0xff3030:0x30ff80);
  beaconPt.color.setHex(slp?0xff3030:0x30ff80);
  bodyMat.color.setHex(slp?0x280808:0x1e2060);
  carFill.color.setHex(slp?0xff4020:0xffeedd);

  tickSmoke(dt);

  // â”€â”€ Brake tab 3D animation â”€â”€
  if(activeTab==='brake'){
    const bspeed = BSIM.vel * SCROLL * 1.2;
    bTiles.forEach(t=>{
      t.position.z -= bspeed * dt;
      if(t.position.z < BCAR.position.z - TILE_L*(TILE_N-.5)) t.position.z += TILE_N*TILE_L;
    });
    bBankTiles.forEach(t=>{
      t.position.z -= bspeed * dt;
      if(t.position.z < BCAR.position.z - TILE_L*(TILE_N-.5)) t.position.z += TILE_N*TILE_L;
    });
    bTrees.forEach(t=>{
      t.position.z -= bspeed * dt;
      if(t.position.z < BCAR.position.z - TILE_L*(TILE_N-1)){
        t.position.z += TILE_N*TILE_L + Math.random()*TILE_L;
        t.position.x = randBX();
      }
    });
    // Wheel spin â€” lock up (stop spinning) when braking hard
    const lockup = BSIM.braking && calcBrakePhysics().decel > 4;
    if(!lockup) bWheelAng += BSIM.vel * 2.8 * dt;
    bWheels.forEach(w=>{ w.rotation.x = bWheelAng; });
    // Brake lights
    brakeLightMat.emissiveIntensity = BSIM.braking ? 3 : 0;
    bBodyMat.color.setHex(BSIM.braking ? 0x280808 : 0x203060);
    // Camera follows brake car
    const bcWorld = new THREE.Vector3();
    BCAR.getWorldPosition(bcWorld);
    camTarget.lerp(bcWorld.add(new THREE.Vector3(0,.8,0)), .07);
  } else {
    const carWorld=new THREE.Vector3();
    car.getWorldPosition(carWorld);
    camTarget.lerp(carWorld.add(new THREE.Vector3(0,.8,0)),.07);
  }

  updateCamera();
  updateSlopePanel(p);
  renderer.render(scene,camera);
}
requestAnimationFrame(animate);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BRAKE TEST LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let brakeRaf=null;

function startBrakeLoop(){
  if(brakeRaf)return;
  let lastT=null;
  function bloop(ts){
    if(!BSIM.braking){brakeRaf=null;return;}
    brakeRaf=requestAnimationFrame(bloop);
    const dt=Math.min((ts-(lastT||ts))/1000,.05);
    lastT=ts;
    const bp=calcBrakePhysics();
    BSIM.vel=Math.max(0,BSIM.vel-bp.decel*dt);
    BSIM.dist+=BSIM.vel*dt;
    document.getElementById('b-dst').textContent=BSIM.dist.toFixed(1)+' m';
    updateBrakePanel(bp);
    if(BSIM.vel<=0){
      BSIM.vel=0;BSIM.braking=false;BSIM.done=true;
      showBrakeResult(bp);
      document.getElementById('btn-brake').textContent='ğŸ›‘ BRAKE';
      document.getElementById('btn-brake').classList.remove('braking');
    }
  }
  brakeRaf=requestAnimationFrame(bloop);
}

function showBrakeResult(bp){
  const box=document.getElementById('b-result-box');
  const dist=BSIM.dist.toFixed(2);
  box.style.display='block';
  const el=document.getElementById('b-result-dist');
  el.textContent=dist;
  el.className='result-big'+(BSIM.dist>50?' bad':BSIM.dist>20?' warn':'');
  const surfName=document.getElementById('b-surf').options[document.getElementById('b-surf').selectedIndex].text;
  document.getElementById('b-result-detail').innerHTML=
    `Started at: <b style="color:#dde0f5">${BST.speedKph} km/h</b><br>`+
    `Surface: <b style="color:#dde0f5">${surfName}</b><br>`+
    `Tyre: <b style="color:#dde0f5">${BST.compound} Â· ${GDATA[BST.groove].note.split(':')[0]}</b><br>`+
    `Slowing rate: <b style="color:#dde0f5">${bp.decel.toFixed(1)} m/sÂ² </b>`;
}

function updateBrakePanel(bp){
  const kph=BSIM.vel*3.6;
  const el=document.getElementById('b-cur-spd');
  el.innerHTML=kph.toFixed(1)+' <small>km/h</small>';
  el.style.color=kph>BST.speedKph*.6?'#ff3030':kph>BST.speedKph*.3?'#f0c040':'#30ff80';
  const pct=BSIM.braking||BSIM.vel>0?kph/BST.speedKph*100:0;
  document.getElementById('b-spd-bar').style.width=pct+'%';
  document.getElementById('b-spd-bar').style.background=pct>60?'#ff3030':pct>30?'#f0c040':'#30ff80';
  setDv('b-decel',bp.decel.toFixed(2)+' m/sÂ²',bp.decel<3?'b':bp.decel<6?'w':'g');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PANEL UPDATES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setDv(id,txt,cls){
  const e=document.getElementById(id);if(!e)return;
  e.textContent=txt;e.className='dv'+(cls?' '+cls:'');
}
function updateSlopePanel(p){
  setDv('d-ang',ST.angle.toFixed(1)+'Â°');
  const v=SIM.vel;
  setDv('d-vel',v.toFixed(2)+' m/s',v>5?'b':v>1?'w':'g');
  setDv('d-acc',p.acc.toFixed(2)+' m/sÂ²',p.acc>2?'b':p.acc>.3?'w':'g');
  setDv('d-dst',SIM.dist.toFixed(1)+' m');
  setDv('d-fd',(p.fD/1000).toFixed(2)+' kN');
  setDv('d-ff',(p.fS/1000).toFixed(2)+' / '+(p.fK/1000).toFixed(2)+' kN');
  setDv('d-thr',p.thr.toFixed(1)+'Â°');
  setDv('d-gm',(p.gm*100).toFixed(0)+'%',p.gm>=1?'g':p.gm>=.8?'w':'b');
  if(SIM.slipping){
    const s=v<.4?'ONSET':v<2.5?'SLIPPING':'SLIDING!';setDv('d-st',s,'b');
  }else{
    const m=(p.fS-p.fD)/Math.max(p.fS,1);setDv('d-st',m<.1?'CRITICAL':'HOLDING',m<.1?'w':'g');
  }
  const gm=Math.max(0,Math.min(1,p.grip));
  const bar=document.getElementById('grip-bar');
  if(bar){bar.style.width=(gm*100)+'%';bar.style.background=gm>.5?'#30ff80':gm>.2?'#f0c040':'#ff3030';}
  document.getElementById('sov').classList.toggle('on',SIM.slipping&&v>.05);
  const sh=document.getElementById('spd');
  if(SIM.slipping&&v>.5){sh.textContent=v.toFixed(1)+' m/s â†“';sh.classList.add('on');}
  else sh.classList.remove('on');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLOPE TAB CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function refreshGnote(){
  const g=GDATA[ST.groove];
  document.getElementById('gnote').textContent=g.note+' ['+ST.surfType+': '+(grooveMult(ST.groove,ST.surfType)*100).toFixed(0)+'%]';
}
document.getElementById('sl-ang').addEventListener('input',function(){
  ST.angle=parseFloat(this.value);
  document.getElementById('v-ang').innerHTML=ST.angle.toFixed(1)+' <small>Â°</small>';
  applyTilt();
});
document.getElementById('sl-mass').addEventListener('input',function(){
  ST.mass=parseFloat(this.value);
  document.getElementById('v-mass').innerHTML=ST.mass+' <small>kg</small>';
});
document.getElementById('sel-surf').addEventListener('change',function(){
  const[mu,t]=this.value.split('|');ST.surfMu=parseFloat(mu);ST.surfType=t;refreshGnote();
});
document.querySelectorAll('[data-c]').forEach(btn=>btn.addEventListener('click',function(){
  document.querySelectorAll('[data-c]').forEach(b=>b.classList.remove('ca'));
  this.classList.add('ca');ST.compound=this.dataset.c;
  wheels.forEach(w=>{if(w.userData.tyreMat)w.userData.tyreMat.color.setHex(CDATA[ST.compound].hexCol);});
  document.getElementById('cnote').textContent=CDATA[ST.compound].note;
}));
document.querySelectorAll('[data-g]').forEach(btn=>btn.addEventListener('click',function(){
  document.querySelectorAll('[data-g]').forEach(b=>b.classList.remove('ga'));
  this.classList.add('ga');ST.groove=parseInt(this.dataset.g);
  wheels.forEach(w=>{if(w.userData.rebuild)w.userData.rebuild();});
  refreshGnote();
}));
document.getElementById('btn-run').addEventListener('click',function(){
  if(SIM.running){SIM.running=false;SIM.slipping=false;SIM.vel=0;this.textContent='â–¶ RUN';this.classList.remove('stop');}
  else{SIM.running=true;this.textContent='â–  STOP';this.classList.add('stop');}
});
document.getElementById('btn-rst').addEventListener('click',function(){
  SIM.vel=0;SIM.slipping=false;SIM.dist=0;
  skidMeshes.forEach(m=>slopeGroup.remove(m));skidMeshes.length=0;
  smokeArr.forEach(m=>scene.remove(m));smokeArr.length=0;
  tiles.forEach((t,i)=>{t.position.z=-i*TILE_L+car.position.z;});
  bankTiles.forEach((t,i)=>{t.position.z=-i*TILE_L+car.position.z;});
  treeMeshes.forEach(t=>{t.position.z=-Math.random()*TILE_L*TILE_N;t.position.x=randX();});
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BRAKE TAB CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function refreshBGnote(){
  const g=GDATA[BST.groove];
  document.getElementById('b-gnote').textContent=g.note+' ['+BST.surfType+': '+(grooveMult(BST.groove,BST.surfType)*100).toFixed(0)+'%]';
}
document.getElementById('b-speed').addEventListener('input',function(){
  BST.speedKph=parseFloat(this.value);
  document.getElementById('bv-speed').innerHTML=BST.speedKph+' <small>km/h</small>';
  if(!BSIM.braking){BSIM.vel=BST.speedKph/3.6;updateBrakePanel(calcBrakePhysics());}
});
document.getElementById('b-mass').addEventListener('input',function(){
  BST.mass=parseFloat(this.value);
  document.getElementById('bv-mass').innerHTML=BST.mass+' <small>kg</small>';
});
document.getElementById('b-surf').addEventListener('change',function(){
  const[mu,t]=this.value.split('|');BST.surfMu=parseFloat(mu);BST.surfType=t;refreshBGnote();
});
document.querySelectorAll('[data-bc]').forEach(btn=>btn.addEventListener('click',function(){
  document.querySelectorAll('[data-bc]').forEach(b=>b.classList.remove('ca'));
  this.classList.add('ca');BST.compound=this.dataset.bc;
  bWheels.forEach(w=>{if(w.userData.tyreMat)w.userData.tyreMat.color.setHex(CDATA[BST.compound].hexCol);});
  document.getElementById('b-cnote').textContent=CDATA[BST.compound].note;
  updateBrakePanel(calcBrakePhysics());
}));
document.querySelectorAll('[data-bg]').forEach(btn=>btn.addEventListener('click',function(){
  document.querySelectorAll('[data-bg]').forEach(b=>b.classList.remove('ga'));
  this.classList.add('ga');BST.groove=parseInt(this.dataset.bg);
  bWheels.forEach(w=>{if(w.userData.rebuild)w.userData.rebuild();});
  refreshBGnote();updateBrakePanel(calcBrakePhysics());
}));

document.getElementById('btn-brake').addEventListener('click',function(){
  if(BSIM.done||BSIM.vel<=0)return;
  BSIM.braking=true;
  this.textContent='BRAKING...';
  this.classList.add('braking');
  document.getElementById('b-result-box').style.display='none';
  startBrakeLoop();
});

document.getElementById('btn-brake-rst').addEventListener('click',function(){
  BSIM.braking=false;BSIM.vel=BST.speedKph/3.6;BSIM.dist=0;BSIM.done=false;
  brakeRaf=null;
  brakeLightMat.emissiveIntensity=0;
  bBodyMat.color.setHex(0x203060);
  // Reset tile positions
  bTiles.forEach((t,i)=>{t.position.z=-i*TILE_L+BCAR.position.z;});
  bBankTiles.forEach((t,i)=>{t.position.z=-i*TILE_L+BCAR.position.z;});
  const bb=document.getElementById('btn-brake');
  bb.textContent='ğŸ›‘ BRAKE';bb.classList.remove('braking');bb.disabled=false;
  document.getElementById('b-result-box').style.display='none';
  document.getElementById('b-dst').textContent='0 m';
  updateBrakePanel(calcBrakePhysics());
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAB SWITCHING (HTML panels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click',function(){
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tabpanel').forEach(p=>p.classList.remove('active'));
    this.classList.add('active');
    document.getElementById('tab-'+this.dataset.tab).classList.add('active');
  });
});

// â”€â”€ Init â”€â”€
refreshGnote();
refreshBGnote();
BSIM.vel=BST.speedKph/3.6;
updateBrakePanel(calcBrakePhysics());

} // end boot
})();
</script>
</body>
</html>
